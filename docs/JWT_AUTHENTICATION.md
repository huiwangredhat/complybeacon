# JWT Authentication with Bound Service Account Tokens

This document describes how to configure Compass to use JWT authentication with Kubernetes bound service account tokens.

## Overview

Compass supports JWT-based authentication using Kubernetes bound service account tokens. This allows services running in the same Kubernetes cluster to authenticate to Compass using short-lived, automatically rotated tokens.

**Security Model**: This implementation provides **full cryptographic signature verification** using the Kubernetes API server's public keys (JWKS). It validates signatures, audience claims, expiration, and service account identity without requiring cluster-admin RBAC permissions.

## How It Works

1. **JWKS Discovery**: On startup, Compass fetches the Kubernetes API server's public keys from the OIDC discovery endpoint
2. **Token Generation**: A client pod (e.g., Collector) is configured with a projected volume that contains a bound service account token with a specific audience
3. **Token Delivery**: The client sends requests to Compass with the token in the `Authorization: Bearer <token>` header
4. **Token Validation**: Compass validates:
   - **Cryptographic signature** using JWKS public keys (verifies token authenticity)
   - **Audience claim** (must match expected audience)
   - **Expiration** (rejects expired tokens)
   - **Subject claim** (validates service account identity)
5. **Access Granted**: If all validations succeed, the request is processed

## Audience Secret Management

The JWT audience value is stored in a Kubernetes Secret for enhanced security:

- **Secret Name**: `compass-jwt-audience`
- **Secret Key**: `audience`
- **Auto-generated**: If not specified, a unique random value is generated (format: `compass-internal-<16-char-hash>`)
- **Deployment reads from Secret**: Both Compass and Collector use the same audience value from the Secret
- **Not visible in ConfigMaps**: The audience value is hidden from casual inspection

### ServiceAccount Name Security

**Auto-generated** (default):
Ansible generates unique random values:
- Audience: `compass-internal-a1b2c3d4e5f67890`
- ServiceAccount: `otel-collector-3f8a9b2c4d5e`

### Why Use Secrets and Random Names?

**Not visible in ConfigMaps** - Audience value is hidden from casual inspection
**Unpredictable ServiceAccount** - Can't be guessed by attackers
**Unique per deployment** - Each deployment has its own values
**Harder to compromise** - Three layers of unpredictable values (audience, SA name, network policy)
**Centrally managed** - Single source of truth for both Compass and Collector

## Security Considerations

### What IS Validated

✅ **Cryptographic signature** - RSA signatures verified using Kubernetes API server's public keys (JWKS)
✅ **Audience claim** - Token must match the expected audience value
✅ **Expiration** - Expired tokens are automatically rejected
✅ **Subject claim** - Only tokens from allowed ServiceAccounts are accepted
✅ **Token authenticity** - Ensures token was issued by the Kubernetes API server
✅ **Automatic rotation** - Kubernetes rotates tokens before expiration

### Security Layers

This implementation provides **defense in depth** with multiple security layers:

1. **Cryptographic Verification** - JWKS-based signature validation ensures token authenticity
2. **Network Isolation** - NetworkPolicy restricts Compass access to authorized pods only
3. **Audience Validation** - Unpredictable audience value stored in Secret
4. **Subject Validation** - Only specific ServiceAccount can authenticate
5. **Short Token Lifetime** - 1-hour expiration limits exposure window
6. **JWKS Caching** - Public keys cached for 1 hour and auto-refreshed

### Token Expiration

- Tokens have a short lifetime (default: 1 hour)
- Kubernetes automatically rotates tokens before expiration (~80% of lifetime)
- Clients should read the token file on each request to get the latest token

### Audience Validation

- The `audience` field in the projected token **must match** the `expectedAudience` in Compass config
- This ensures tokens can only be used for their intended purpose
- Mismatch will result in authentication failure

## Benefits

- **Full cryptographic verification** - RSA signature validation using JWKS ensures token authenticity
- **No secrets to manage** - Tokens are auto-generated by Kubernetes
- **Automatic rotation** - Tokens are refreshed before expiration
- **Scoped access** - Tokens only work for specified audience
- **Short-lived** - Limited exposure window if compromised (1-hour expiration)
- **Pod-bound** - Tokens tied to specific service accounts and pods
- **No RBAC required** - Full signature verification without cluster-admin permissions
- **Simple deployment** - No ClusterRole or ClusterRoleBinding needed
- **Defense in depth** - Multiple security layers (signature + audience + subject + network + expiration)

## Troubleshooting

### JWKS Fetch Timeout Errors

**Problem**: Compass fails to start with errors like "failed to fetch JWKS on startup" or timeout errors when fetching OIDC discovery.

**Root Cause**: Slow network connections or DNS resolution delays can cause JWKS fetching to timeout during startup.

**Solutions**:

1. **Automatic Retry Logic** (built-in since v1.x):
   - Compass automatically retries JWKS fetch 3 times with exponential backoff (1s, 2s, 4s)
   - Extended timeout from 10s to 30s for slower networks
   - If startup retries fail, JWKS will be fetched on first request

2. **Check Logs**:
   ```
   level=INFO msg="attempting OIDC discovery" url=https://kubernetes.default.svc/.well-known/openid-configuration
   level=INFO msg="OIDC discovery request completed" elapsed=5.2s status=200
   level=INFO msg="successfully fetched JWKS on startup" attempt=1
   ```

3. **DNS Bypass Mode** (for persistent DNS issues):
   If you experience ongoing DNS resolution problems, you can bypass DNS and connect directly to the Kubernetes API using its ClusterIP:

   ```yaml
   env:
   - name: KUBERNETES_SERVICE_IP
     value: "10.0.0.1"  # Replace with your cluster's kubernetes.default.svc ClusterIP
   ```

   To find your Kubernetes API ClusterIP:
   ```bash
   kubectl get svc kubernetes -n default -o jsonpath='{.spec.clusterIP}'
   ```

   **Important**: DNS bypass maintains full TLS security by:
   - Connecting to the IP address at the network layer (e.g., `10.0.0.1:443`)
   - Setting SNI (Server Name Indication) to `kubernetes.default.svc` during TLS handshake
   - Validating the certificate against the hostname, not the IP
   - This allows secure connections even when DNS resolution fails

### Connection and Network Issues

**Problem**: Intermittent connection failures or "connection reset" errors when fetching JWKS.

**Solutions**:

1. **Secure TLS Configuration** (automatic):
   - Full certificate validation using Kubernetes CA certificate
   - Proper SNI (Server Name Indication) set to match Kubernetes certificates
   - HTTP/2 support enabled for better performance
   - Connection pooling with keep-alives (10 max idle connections, 30s timeout)

2. **CA Certificate Validation**:
   - CA certificate validation is performed using `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
   - Ensures all connections to the Kubernetes API are cryptographically verified
   - No insecure TLS configurations (InsecureSkipVerify is NOT used)

   **Technical Detail - SNI Configuration**:
   When DNS bypass mode is enabled, Compass connects to the Kubernetes API IP directly (e.g., `10.0.0.1:443`) but the TLS certificate is issued for the hostname (`kubernetes.default.svc`). The SNI field in the TLS configuration is explicitly set to `kubernetes.default.svc` to ensure:
   - The TLS handshake sends the correct hostname in the SNI extension
   - Certificate validation checks against the hostname, not the IP address
   - Secure connections work even when bypassing DNS resolution
   - This is the correct and secure way to handle IP-based connections with hostname-based certificates

3. **Verify Service Account Mount**:
   Ensure the service account token and CA cert are properly mounted:
   ```bash
   kubectl exec -it <compass-pod> -- ls -la /var/run/secrets/kubernetes.io/serviceaccount/
   # Should show: ca.crt, namespace, token
   ```

### Authentication Failures

**Problem**: Requests fail with "invalid token signature" or "authentication failed".

**Check These Common Issues**:

1. **Audience Mismatch**:
   ```
   # Verify the audience in both Compass config and Collector token volume match
   kubectl get secret compass-jwt-audience -o jsonpath='{.data.audience}' | base64 -d
   ```

2. **Expired Token**:
   - Ensure Kubernetes is rotating tokens (happens automatically at ~80% of lifetime)
   - Client must read token file on each request, not cache in memory

3. **Wrong Service Account**:
   - Verify the token's subject claim matches allowed subjects in Compass config
   - Check logs for "subject validation failed" messages

4. **Token Not Bound**:
   - Ensure the client pod has a projected volume with bound service account token
   - Verify the `audience` field is set in the projected volume configuration

### Debugging with Logs

Compass provides detailed info-level logging for JWT authentication:

```
level=INFO msg="using standard DNS resolution for Kubernetes API"
level=INFO msg="fetching JWKS from Kubernetes API server"
level=INFO msg="attempting OIDC discovery" url=...
level=INFO msg="OIDC discovery request completed" elapsed=1.2s status=200
level=INFO msg="using service account token for JWKS authentication"
level=INFO msg="attempting JWKS fetch" url=...
level=INFO msg="JWKS fetch completed" elapsed=0.8s status=200
level=INFO msg="jwt signature verification successful"
level=INFO msg="jwt audience validation successful"
level=INFO msg="jwt subject validation successful"
level=INFO msg="jwt authentication successful"
```

Enable debug logging to see additional details like issuer, JWKS URI, and claim values.

### Performance Considerations

**JWKS Caching**:
- Public keys are cached for 1 hour to avoid excessive API calls
- Cache is automatically refreshed when expired
- Failed JWKS fetch will use stale cache if available

**Timeouts Configuration**:
- Overall request timeout: 30s
- TLS handshake timeout: 10s
- Response header timeout: 20s
- DNS/connection timeout: 15s

If you experience slower network conditions, these timeouts should accommodate most scenarios. The retry logic provides additional resilience.
