# JWT Authentication with Bound Service Account Tokens

This document describes how to configure Compass to use JWT authentication with Kubernetes bound service account tokens.

## Overview

Compass supports JWT-based authentication using Kubernetes bound service account tokens. This allows services running in the same Kubernetes cluster to authenticate to Compass using short-lived, automatically rotated tokens.

**Security Model**: This implementation provides **full cryptographic signature verification** using the Kubernetes API server's public keys (JWKS). It validates signatures, audience claims, expiration, and service account identity without requiring cluster-admin RBAC permissions.

## How It Works

1. **JWKS Discovery**: On startup, Compass fetches the Kubernetes API server's public keys from the OIDC discovery endpoint
2. **Token Generation**: A client pod (e.g., Collector) is configured with a projected volume that contains a bound service account token with a specific audience
3. **Token Delivery**: The client sends requests to Compass with the token in the `Authorization: Bearer <token>` header
4. **Token Validation**: Compass validates:
   - **Cryptographic signature** using JWKS public keys (verifies token authenticity)
   - **Audience claim** (must match expected audience)
   - **Expiration** (rejects expired tokens)
   - **Subject claim** (validates service account identity)
5. **Access Granted**: If all validations succeed, the request is processed

## Audience Secret Management

The JWT audience value is stored in a Kubernetes Secret for enhanced security:

- **Secret Name**: `compass-jwt-audience`
- **Secret Key**: `audience`
- **Auto-generated**: If not specified, a unique random value is generated (format: `compass-internal-<16-char-hash>`)
- **Deployment reads from Secret**: Both Compass and Collector use the same audience value from the Secret
- **Not visible in ConfigMaps**: The audience value is hidden from casual inspection

### ServiceAccount Name Security

**Auto-generated** (default):
Ansible generates unique random values:
- Audience: `compass-internal-a1b2c3d4e5f67890`
- ServiceAccount: `otel-collector-3f8a9b2c4d5e`

### Why Use Secrets and Random Names?

**Not visible in ConfigMaps** - Audience value is hidden from casual inspection
**Unpredictable ServiceAccount** - Can't be guessed by attackers
**Unique per deployment** - Each deployment has its own values
**Harder to compromise** - Three layers of unpredictable values (audience, SA name, network policy)
**Centrally managed** - Single source of truth for both Compass and Collector

## Security Considerations

### What IS Validated

✅ **Cryptographic signature** - RSA signatures verified using Kubernetes API server's public keys (JWKS)
✅ **Audience claim** - Token must match the expected audience value
✅ **Expiration** - Expired tokens are automatically rejected
✅ **Subject claim** - Only tokens from allowed ServiceAccounts are accepted
✅ **Token authenticity** - Ensures token was issued by the Kubernetes API server
✅ **Automatic rotation** - Kubernetes rotates tokens before expiration

### Security Layers

This implementation provides **defense in depth** with multiple security layers:

1. **Cryptographic Verification** - JWKS-based signature validation ensures token authenticity
2. **Network Isolation** - NetworkPolicy restricts Compass access to authorized pods only
3. **Audience Validation** - Unpredictable audience value stored in Secret
4. **Subject Validation** - Only specific ServiceAccount can authenticate
5. **Short Token Lifetime** - 1-hour expiration limits exposure window
6. **JWKS Caching** - Public keys cached for 1 hour and auto-refreshed

### Token Expiration

- Tokens have a short lifetime (default: 1 hour)
- Kubernetes automatically rotates tokens before expiration (~80% of lifetime)
- Clients should read the token file on each request to get the latest token

### Audience Validation

- The `audience` field in the projected token **must match** the `expectedAudience` in Compass config
- This ensures tokens can only be used for their intended purpose
- Mismatch will result in authentication failure

## Benefits

- **Full cryptographic verification** - RSA signature validation using JWKS ensures token authenticity
- **No secrets to manage** - Tokens are auto-generated by Kubernetes
- **Automatic rotation** - Tokens are refreshed before expiration
- **Scoped access** - Tokens only work for specified audience
- **Short-lived** - Limited exposure window if compromised (1-hour expiration)
- **Pod-bound** - Tokens tied to specific service accounts and pods
- **No RBAC required** - Full signature verification without cluster-admin permissions
- **Simple deployment** - No ClusterRole or ClusterRoleBinding needed
- **Defense in depth** - Multiple security layers (signature + audience + subject + network + expiration)
